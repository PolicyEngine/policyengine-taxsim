"""Parser for PolicyEngine output.txt files."""

import re
from pathlib import Path
from typing import Dict, Optional


class PolicyEngineOutputParser:
    """Parses output.txt files generated by PolicyEngine-TAXSIM."""

    def __init__(self, output_file: Path):
        self.output_file = output_file
        self.content = self._read_file()

    def _read_file(self) -> str:
        """Read the output file content."""
        try:
            with open(self.output_file, 'r') as f:
                return f.read()
        except Exception as e:
            print(f"Warning: Could not read {self.output_file}: {e}")
            return ""

    def _extract_value(self, pattern: str) -> Optional[float]:
        """Extract a numeric value using regex pattern."""
        match = re.search(pattern, self.content, re.MULTILINE)
        if match:
            try:
                value_str = match.group(1).replace(',', '').strip()
                return float(value_str)
            except (ValueError, IndexError):
                return None
        return None

    def parse_basic_output(self) -> Dict[str, float]:
        """Parse the 'Basic Output' section."""
        values = {}

        patterns = {
            'fica': r'FICA.*?(\d+\.?\d*)',
            'federal_income_tax': r'Federal IIT Liability\s+(\d+\.?\d*)',
            'state_income_tax': r'State IIT Liability\s+(\d+\.?\d*)',
        }

        for key, pattern in patterns.items():
            value = self._extract_value(pattern)
            if value is not None:
                values[key] = value

        return values

    def parse_federal_tax_calculation(self) -> Dict[str, float]:
        """Parse the 'Federal Tax Calculation' section."""
        values = {}

        patterns = {
            'federal_agi': r'Federal AGI\s+(\d+\.?\d*)',
            'federal_taxable_income': r'Federal Taxable Income\s+(\d+\.?\d*)',
            'federal_tax_before_credits': r'Federal Income Tax Before Credits\s+(\d+\.?\d*)',
            'federal_regular_tax': r'Federal Regular Tax\s+(\d+\.?\d*)',
            'child_tax_credit': r'Child Tax Credit\s+(\d+\.?\d*)',
            'earned_income_credit': r'Earned Income Credit\s+(\d+\.?\d*)',
            'child_care_credit': r'Child Care Credit\s+(\d+\.?\d*)',
            'amt_liability': r'AMT Liability.*?(\d+\.?\d*)',
            'qbi_deduction': r'QBI deduction\s+(\d+\.?\d*)',
            'standard_deduction': r'Zero Bracket Amount / Standard Deduction\s+(\d+\.?\d*)',
            'itemized_deductions': r'Itemized Deductions in taxable income\s+(\d+\.?\d*)',
        }

        for key, pattern in patterns.items():
            value = self._extract_value(pattern)
            if value is not None:
                values[key] = value

        return values

    def parse_state_tax_calculation(self) -> Dict[str, float]:
        """Parse the 'State Tax Calculation' section."""
        values = {}

        patterns = {
            'state_agi': r'32\. AGI\s+(\d+\.?\d*)',
            'state_standard_deduction': r'34\. Standard Deduction\s+(\d+\.?\d*)',
            'state_itemized_deductions': r'35\. Itemized Deductions\s+(\d+\.?\d*)',
            'state_taxable_income': r'36\. Taxable Income\s+(\d+\.?\d*)',
            'property_tax_credit': r'37\. Property Tax Credit\s+(\d+\.?\d*)',
            'state_child_care_credit': r'38\. Child Care Credit\s+(\d+\.?\d*)',
            'state_eic': r'39\. EIC\s+(\d+\.?\d*)',
            'state_total_credits': r'40\. Total Credits\s+(\d+\.?\d*)',
            'state_child_tax_credit': r'Child Tax Credit\s+(\d+\.?\d*)',
            'state_tax_before_credits': r'Tax before credits\s+(\d+\.?\d*)',
        }

        for key, pattern in patterns.items():
            value = self._extract_value(pattern)
            if value is not None:
                values[key] = value

        return values

    def parse_all(self) -> Dict[str, float]:
        """Parse all sections and return consolidated values."""
        all_values = {}

        # Parse each section
        all_values.update(self.parse_basic_output())
        all_values.update(self.parse_federal_tax_calculation())
        all_values.update(self.parse_state_tax_calculation())

        return all_values

    def get_specific_value(self, variable_name: str) -> Optional[float]:
        """Get a specific value by name."""
        all_values = self.parse_all()
        return all_values.get(variable_name)

    def extract_version_info(self) -> Dict[str, str]:
        """Extract PolicyEngine version information."""
        version_info = {}

        # Extract policyengine-us version
        pe_us_match = re.search(r'Name: policyengine-us\s+Version: ([\d.]+)', self.content)
        if pe_us_match:
            version_info['policyengine_us'] = pe_us_match.group(1)

        # Extract policyengine-taxsim version
        pe_taxsim_match = re.search(r'Name: policyengine-taxsim\s+Version: ([\d.]+)', self.content)
        if pe_taxsim_match:
            version_info['policyengine_taxsim'] = pe_taxsim_match.group(1)

        return version_info
